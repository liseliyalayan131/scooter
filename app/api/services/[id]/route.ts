import { NextRequest, NextResponse } from 'next/server';
import dbConnect from '@/lib/mongodb';
import Service from '@/lib/models/Service';
import Transaction from '@/lib/models/Transaction';

// Tip tanƒ±mlarƒ±
interface ServiceDocument {
  _id: any;
  customerId?: any;
  customerName: string;
  customerPhone: string;
  customerAddress: string;
  customerEmail: string;
  isRegisteredCustomer: boolean;
  scooterBrand: string;
  scooterModel: string;
  serialNumber: string;
  problem: string;
  solution: string;
  cost: number;
  laborCost: number;
  partsCost: number;
  status: 'beklemede' | 'devam-ediyor' | 'tamamlandi' | 'iptal';
  receivedDate: Date;
  completedDate?: Date;
  notes: string;
  warrantyDays: number;
  customerRating?: number;
  customerFeedback: string;
  createdAt: Date;
  updatedAt: Date;
  toObject?: () => any;
}

interface Target {
  _id: any;
  period: string;
  targetAmount: number;
  currentAmount: number;
  status: string;
}

// Hedef sistemini g√ºncelle - d√ºzeltildi
async function updateTargets() {
  try {
    console.log('üéØ Hedef g√ºncelleme ba≈ülƒ±yor...');
    
    await dbConnect();
    const mongoose = require('mongoose');
    const db = mongoose.connection.db;
    
    const targets = await db.collection('targets').find({ status: 'active' }).toArray() as Target[];
    
    for (const target of targets) {
      const { startDate, endDate } = calculatePeriodDates(target.period);
      
      // Sadece createdAt field'ƒ±nƒ± kullan
      const result = await db.collection('transactions').aggregate([
        {
          $match: {
            type: { $in: ['gelir', 'satis'] },
            createdAt: { 
              $gte: startDate,
              $lt: endDate
            }
          }
        },
        {
          $group: {
            _id: null,
            total: { $sum: '$amount' }
          }
        }
      ]).toArray();
      
      const currentAmount = result[0]?.total || 0;
      
      // Durum g√ºncelle
      let status = 'active';
      if (currentAmount >= target.targetAmount) {
        status = 'completed';
      } else if (new Date() > endDate) {
        status = 'expired';
      }
      
      await db.collection('targets').updateOne(
        { _id: target._id },
        { 
          $set: { 
            currentAmount,
            status,
            startDate: startDate.toISOString(),
            endDate: endDate.toISOString()
          }
        }
      );
    }
    
    console.log('üéØ Hedefler g√ºncellendi!');
  } catch (error) {
    console.error('‚ùå Target update error:', error);
  }
}

// D√∂nem hesaplama fonksiyonu
function calculatePeriodDates(period: string) {
  const now = new Date();
  let startDate: Date;
  let endDate: Date;

  switch (period) {
    case 'daily':
      startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
      endDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 0, 0, 0, 0);
      break;
    case 'weekly':
      const dayOfWeek = now.getDay();
      startDate = new Date(now);
      startDate.setDate(now.getDate() - dayOfWeek);
      startDate.setHours(0, 0, 0, 0);
      endDate = new Date(startDate);
      endDate.setDate(startDate.getDate() + 7);
      break;
    case 'monthly':
      startDate = new Date(now.getFullYear(), now.getMonth(), 1, 0, 0, 0, 0);
      endDate = new Date(now.getFullYear(), now.getMonth() + 1, 1, 0, 0, 0, 0);
      break;
    case 'yearly':
      startDate = new Date(now.getFullYear(), 0, 1, 0, 0, 0, 0);
      endDate = new Date(now.getFullYear() + 1, 0, 1, 0, 0, 0, 0);
      break;
    default:
      startDate = new Date(now.getFullYear(), now.getMonth(), 1, 0, 0, 0, 0);
      endDate = new Date(now.getFullYear(), now.getMonth() + 1, 1, 0, 0, 0, 0);
  }

  return { startDate, endDate };
}

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  try {
    console.log('üîç Servis kaydƒ± aranƒ±yor:', params.id);
    await dbConnect();
    
    const service = await Service.findById(params.id).lean() as ServiceDocument | null;
    
    if (!service) {
      return NextResponse.json({ error: 'Servis kaydƒ± bulunamadƒ±' }, { status: 404 });
    }
    
    // Kayƒ±tlƒ± m√º≈üteri bilgilerini al
    let responseService = service;
    if (service.isRegisteredCustomer && service.customerId) {
      const mongoose = require('mongoose');
      const db = mongoose.connection.db;
      
      const customer = await db.collection('customers').findOne({
        _id: service.customerId
      }, {
        projection: {
          firstName: 1,
          lastName: 1,
          phone: 1,
          email: 1,
          loyaltyPoints: 1,
          totalSpent: 1,
          visitCount: 1
        }
      });
      
      responseService = {
        ...service,
        customerId: customer || null
      };
    }
    
    console.log('‚úÖ Servis kaydƒ± bulundu:', service.customerName, '-', service.scooterBrand, service.scooterModel);
    return NextResponse.json(responseService);
  } catch (error) {
    console.error('‚ùå Service GET error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Bilinmeyen hata';
    return NextResponse.json({ error: 'Servis kaydƒ± alƒ±namadƒ±: ' + errorMessage }, { status: 500 });
  }
}

export async function PUT(request: NextRequest, { params }: { params: { id: string } }) {
  try {
    console.log('üîß Servis kaydƒ± g√ºncelleniyor:', params.id);
    await dbConnect();
    const body = await request.json();
    
    // Mevcut servis durumunu kontrol et
    const currentService = await Service.findById(params.id) as ServiceDocument | null;
    if (!currentService) {
      return NextResponse.json({ error: 'Servis kaydƒ± bulunamadƒ±' }, { status: 404 });
    }
    
    console.log('üìã √ñnceki durum:', currentService.status, '‚Üí Yeni durum:', body.status);
    
    // Kayƒ±tlƒ± m√º≈üteri bilgilerini al
    let customerData = {
      customerName: body.customerName,
      customerPhone: body.customerPhone,
      customerAddress: body.customerAddress || '',
      customerEmail: body.customerEmail || '',
      isRegisteredCustomer: false,
      customerId: null
    };

    // Eƒüer kayƒ±tlƒ± m√º≈üteri se√ßildiyse
    if (body.customerId) {
      const mongoose = require('mongoose');
      const db = mongoose.connection.db;
      
      const customer = await db.collection('customers').findOne({ 
        _id: new mongoose.Types.ObjectId(body.customerId) 
      });
      
      if (customer) {
        customerData = {
          customerName: `${customer.firstName} ${customer.lastName}`,
          customerPhone: customer.phone,
          customerAddress: customer.address || '',
          customerEmail: customer.email || '',
          isRegisteredCustomer: true,
          customerId: body.customerId
        };
        
        console.log('üëë Kayƒ±tlƒ± m√º≈üteri g√ºncellendi:', customerData.customerName);
      }
    }
    
    const service = await Service.findByIdAndUpdate(
      params.id,
      {
        ...customerData,
        scooterBrand: body.scooterBrand,
        scooterModel: body.scooterModel,
        serialNumber: body.serialNumber || '',
        problem: body.problem,
        solution: body.solution || '',
        cost: body.cost,
        laborCost: body.laborCost || 0,
        partsCost: body.partsCost || 0,
        status: body.status,
        receivedDate: body.receivedDate,
        completedDate: body.completedDate || null,
        notes: body.notes || '',
        warrantyDays: body.warrantyDays || 30,
        customerRating: body.customerRating || null,
        customerFeedback: body.customerFeedback || ''
      },
      { new: true }
    ) as ServiceDocument | null;

    if (!service) {
      return NextResponse.json({ error: 'Servis kaydƒ± bulunamadƒ±' }, { status: 404 });
    }

    // Eƒüer servis durumu 'tamamlandi' olarak g√ºncellendi ve daha √∂nce tamamlandi deƒüilse, transaction olu≈ütur
    if (body.status === 'tamamlandi' && currentService.status !== 'tamamlandi' && body.cost > 0) {
      console.log('üí∞ Servis tamamlandƒ± - Transaction kontrol ediliyor...');
      
      // Daha √∂nce aynƒ± servis i√ßin gelir kaydƒ± var mƒ± kontrol et
      const existingTransaction = await Transaction.findOne({
        type: 'gelir',
        description: { $regex: `Servis Geliri: ${customerData.customerName}.*${body.scooterBrand}.*${body.scooterModel}` }
      });
      
      if (!existingTransaction) {
        console.log('üìù Yeni transaction olu≈üturuluyor...');
        const transaction = new Transaction({
          type: 'gelir',
          amount: body.cost,
          description: `Servis Geliri: ${customerData.customerName} - ${body.scooterBrand} ${body.scooterModel} (${body.problem})`,
          category: 'Servis',
          customerName: customerData.customerName,
          customerPhone: customerData.customerPhone
        });
        
        await transaction.save();
        console.log('‚úÖ Transaction olu≈üturuldu:', transaction._id);
        
        // Hedef sistemini g√ºncelle
        console.log('üéØ Hedef g√ºncelleme tetikleniyor...');
        await updateTargets();
      } else {
        console.log('‚ö†Ô∏è Bu servis i√ßin zaten transaction mevcut');
      }
    }

    // Response i√ßin m√º≈üteri bilgilerini ekle
    let responseService = service.toObject ? service.toObject() : service;
    if (customerData.isRegisteredCustomer && customerData.customerId) {
      const mongoose = require('mongoose');
      const db = mongoose.connection.db;
      
      const customer = await db.collection('customers').findOne({
        _id: new mongoose.Types.ObjectId(customerData.customerId)
      });
      
      responseService.customerId = customer;
    }

    console.log('‚úÖ Servis kaydƒ± g√ºncellendi:', service._id);
    return NextResponse.json(responseService);
  } catch (error) {
    console.error('‚ùå Service PUT error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Bilinmeyen hata';
    return NextResponse.json({ error: 'Servis kaydƒ± g√ºncellenemedi: ' + errorMessage }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest, { params }: { params: { id: string } }) {
  try {
    console.log('üóëÔ∏è Servis kaydƒ± siliniyor:', params.id);
    await dbConnect();
    const service = await Service.findByIdAndDelete(params.id) as ServiceDocument | null;
    
    if (!service) {
      return NextResponse.json({ error: 'Servis kaydƒ± bulunamadƒ±' }, { status: 404 });
    }
    
    console.log('‚úÖ Servis kaydƒ± silindi:', service._id);
    return NextResponse.json({ message: 'Servis kaydƒ± silindi' });
  } catch (error) {
    console.error('‚ùå Service DELETE error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Bilinmeyen hata';
    return NextResponse.json({ error: 'Servis kaydƒ± silinemedi: ' + errorMessage }, { status: 500 });
  }
}